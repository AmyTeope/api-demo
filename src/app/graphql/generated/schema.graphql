### This file was generated by Nexus Schema
### Do not make changes to this file directly

type AggregateComment {
  _avg: CommentAvgAggregateOutputType
  _count: CommentCountAggregateOutputType
  _max: CommentMaxAggregateOutputType
  _min: CommentMinAggregateOutputType
  _sum: CommentSumAggregateOutputType
}

type AggregatePost {
  _avg: PostAvgAggregateOutputType
  _count: PostCountAggregateOutputType
  _max: PostMaxAggregateOutputType
  _min: PostMinAggregateOutputType
  _sum: PostSumAggregateOutputType
}

type AggregateRating {
  _avg: RatingAvgAggregateOutputType
  _count: RatingCountAggregateOutputType
  _max: RatingMaxAggregateOutputType
  _min: RatingMinAggregateOutputType
  _sum: RatingSumAggregateOutputType
}

type AggregateUser {
  _avg: UserAvgAggregateOutputType
  _count: UserCountAggregateOutputType
  _max: UserMaxAggregateOutputType
  _min: UserMinAggregateOutputType
  _sum: UserSumAggregateOutputType
}

type BatchPayload {
  count: Int!
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt
"""
scalar BigInt

"""
The `Byte` scalar type represents byte value as a Buffer
"""
scalar Bytes

type Comment {
  commentedAt: DateTime!
  createdAt: DateTime!
  id: Int!
  message: String!
  post: Post!
  postId: Int!
  updatedAt: DateTime!
  user: User!
  userId: Int!
}

type CommentAvgAggregateOutputType {
  id: Float
  postId: Float
  userId: Float
}

input CommentAvgOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  userId: SortOrder
}

type CommentCountAggregateOutputType {
  _all: Int!
  commentedAt: Int!
  createdAt: Int!
  id: Int!
  message: Int!
  postId: Int!
  updatedAt: Int!
  userId: Int!
}

input CommentCountOrderByAggregateInput {
  commentedAt: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input CommentCreateInput {
  commentedAt: DateTime
  createdAt: DateTime
  message: String!
  post: PostCreateNestedOneWithoutCommentsInput!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutCommentsInput!
}

input CommentCreateManyInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String!
  postId: Int!
  updatedAt: DateTime
  userId: Int!
}

input CommentCreateManyPostInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String!
  updatedAt: DateTime
  userId: Int!
}

input CommentCreateManyPostInputEnvelope {
  data: CommentCreateManyPostInput!
  skipDuplicates: Boolean
}

input CommentCreateManyUserInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String!
  postId: Int!
  updatedAt: DateTime
}

input CommentCreateManyUserInputEnvelope {
  data: CommentCreateManyUserInput!
  skipDuplicates: Boolean
}

input CommentCreateNestedManyWithoutPostInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput]
  create: [CommentCreateWithoutPostInput]
  createMany: CommentCreateManyPostInputEnvelope
}

input CommentCreateNestedManyWithoutUserInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput]
  create: [CommentCreateWithoutUserInput]
  createMany: CommentCreateManyUserInputEnvelope
}

input CommentCreateOrConnectWithoutPostInput {
  create: CommentUncheckedCreateWithoutPostInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutUserInput {
  create: CommentUncheckedCreateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutPostInput {
  commentedAt: DateTime
  createdAt: DateTime
  message: String!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutCommentsInput!
}

input CommentCreateWithoutUserInput {
  commentedAt: DateTime
  createdAt: DateTime
  message: String!
  post: PostCreateNestedOneWithoutCommentsInput!
  updatedAt: DateTime
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

type CommentMaxAggregateOutputType {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String
  postId: Int
  updatedAt: DateTime
  userId: Int
}

input CommentMaxOrderByAggregateInput {
  commentedAt: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type CommentMinAggregateOutputType {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String
  postId: Int
  updatedAt: DateTime
  userId: Int
}

input CommentMinOrderByAggregateInput {
  commentedAt: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentOrderByWithAggregationInput {
  _avg: CommentAvgOrderByAggregateInput
  _count: CommentCountOrderByAggregateInput
  _max: CommentMaxOrderByAggregateInput
  _min: CommentMinOrderByAggregateInput
  _sum: CommentSumOrderByAggregateInput
  commentedAt: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input CommentOrderByWithRelationInput {
  commentedAt: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  post: PostOrderByWithRelationInput
  postId: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum CommentScalarFieldEnum {
  commentedAt
  createdAt
  id
  message
  postId
  updatedAt
  userId
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput]
  NOT: [CommentScalarWhereInput]
  OR: [CommentScalarWhereInput]
  commentedAt: DateTimeFilter
  createdAt: DateTimeFilter
  id: IntFilter
  message: StringFilter
  postId: IntFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input CommentScalarWhereWithAggregatesInput {
  AND: [CommentScalarWhereWithAggregatesInput]
  NOT: [CommentScalarWhereWithAggregatesInput]
  OR: [CommentScalarWhereWithAggregatesInput]
  commentedAt: DateTimeWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  message: StringWithAggregatesFilter
  postId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type CommentSumAggregateOutputType {
  id: Int
  postId: Int
  userId: Int
}

input CommentSumOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  userId: SortOrder
}

input CommentUncheckedCreateInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String!
  postId: Int!
  updatedAt: DateTime
  userId: Int!
}

input CommentUncheckedCreateNestedManyWithoutPostInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput]
  create: [CommentCreateWithoutPostInput]
  createMany: CommentCreateManyPostInputEnvelope
}

input CommentUncheckedCreateNestedManyWithoutUserInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput]
  create: [CommentCreateWithoutUserInput]
  createMany: CommentCreateManyUserInputEnvelope
}

input CommentUncheckedCreateWithoutPostInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String!
  updatedAt: DateTime
  userId: Int!
}

input CommentUncheckedCreateWithoutUserInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String!
  postId: Int!
  updatedAt: DateTime
}

input CommentUncheckedUpdateInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String
  postId: Int
  updatedAt: DateTime
  userId: Int
}

input CommentUncheckedUpdateManyInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String
  postId: Int
  updatedAt: DateTime
  userId: Int
}

input CommentUncheckedUpdateManyWithoutCommentsInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String
  updatedAt: DateTime
  userId: Int
}

input CommentUncheckedUpdateManyWithoutPostNestedInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput]
  create: [CommentCreateWithoutPostInput]
  createMany: CommentCreateManyPostInputEnvelope
  delete: [CommentWhereUniqueInput]
  deleteMany: [CommentScalarWhereInput]
  disconnect: [CommentWhereUniqueInput]
  set: [CommentWhereUniqueInput]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput]
  updateMany: [CommentUpdateManyWithWhereWithoutPostInput]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput]
}

input CommentUncheckedUpdateManyWithoutUserNestedInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput]
  create: [CommentCreateWithoutUserInput]
  createMany: CommentCreateManyUserInputEnvelope
  delete: [CommentWhereUniqueInput]
  deleteMany: [CommentScalarWhereInput]
  disconnect: [CommentWhereUniqueInput]
  set: [CommentWhereUniqueInput]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput]
}

input CommentUncheckedUpdateWithoutPostInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String
  updatedAt: DateTime
  userId: Int
}

input CommentUncheckedUpdateWithoutUserInput {
  commentedAt: DateTime
  createdAt: DateTime
  id: Int
  message: String
  postId: Int
  updatedAt: DateTime
}

input CommentUpdateInput {
  commentedAt: DateTime
  createdAt: DateTime
  message: String
  post: PostUpdateOneRequiredWithoutCommentsNestedInput
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutCommentsNestedInput
}

input CommentUpdateManyMutationInput {
  commentedAt: DateTime
  createdAt: DateTime
  message: String
  updatedAt: DateTime
}

input CommentUpdateManyWithWhereWithoutPostInput {
  data: CommentUncheckedUpdateManyWithoutCommentsInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithWhereWithoutUserInput {
  data: CommentUncheckedUpdateManyWithoutCommentsInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutPostNestedInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput]
  create: [CommentCreateWithoutPostInput]
  createMany: CommentCreateManyPostInputEnvelope
  delete: [CommentWhereUniqueInput]
  deleteMany: [CommentScalarWhereInput]
  disconnect: [CommentWhereUniqueInput]
  set: [CommentWhereUniqueInput]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput]
  updateMany: [CommentUpdateManyWithWhereWithoutPostInput]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput]
}

input CommentUpdateManyWithoutUserNestedInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput]
  create: [CommentCreateWithoutUserInput]
  createMany: CommentCreateManyUserInputEnvelope
  delete: [CommentWhereUniqueInput]
  deleteMany: [CommentScalarWhereInput]
  disconnect: [CommentWhereUniqueInput]
  set: [CommentWhereUniqueInput]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput]
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  data: CommentUncheckedUpdateWithoutPostInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
  data: CommentUncheckedUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutPostInput {
  commentedAt: DateTime
  createdAt: DateTime
  message: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutCommentsNestedInput
}

input CommentUpdateWithoutUserInput {
  commentedAt: DateTime
  createdAt: DateTime
  message: String
  post: PostUpdateOneRequiredWithoutCommentsNestedInput
  updatedAt: DateTime
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  create: CommentUncheckedCreateWithoutPostInput!
  update: CommentUncheckedUpdateWithoutPostInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
  create: CommentUncheckedCreateWithoutUserInput!
  update: CommentUncheckedUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput]
  NOT: [CommentWhereInput]
  OR: [CommentWhereInput]
  commentedAt: DateTimeFilter
  createdAt: DateTimeFilter
  id: IntFilter
  message: StringFilter
  post: PostWhereInput
  postId: IntFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: IntFilter
}

input CommentWhereUniqueInput {
  id: Int
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

"""
An arbitrary-precision Decimal type
"""
scalar Decimal

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json
  @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createOneComment(data: CommentCreateInput!): Comment!
  createOnePost(data: PostCreateInput!): Post!
  createOneRating(data: RatingCreateInput!): Rating!
  createOneUser(data: UserCreateInput!): User!
  deleteManyComment(where: CommentWhereInput): BatchPayload!
  deleteManyPost(where: PostWhereInput): BatchPayload!
  deleteManyRating(where: RatingWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneComment(where: CommentWhereUniqueInput!): Comment
  deleteOnePost(where: PostWhereUniqueInput!): Post
  deleteOneRating(where: RatingWhereUniqueInput!): Rating
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  updateManyRating(data: RatingUpdateManyMutationInput!, where: RatingWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  updateOnePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  updateOneRating(data: RatingUpdateInput!, where: RatingWhereUniqueInput!): Rating!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneComment(
    create: CommentCreateInput!
    update: CommentUpdateInput!
    where: CommentWhereUniqueInput!
  ): Comment!
  upsertOnePost(
    create: PostCreateInput!
    update: PostUpdateInput!
    where: PostWhereUniqueInput!
  ): Post!
  upsertOneRating(
    create: RatingCreateInput!
    update: RatingUpdateInput!
    where: RatingWhereUniqueInput!
  ): Rating!
  upsertOneUser(
    create: UserCreateInput!
    update: UserUpdateInput!
    where: UserWhereUniqueInput!
  ): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Post {
  _count: PostCountOutputType!
  body: String!
  comments(
    cursor: CommentWhereUniqueInput
    distinct: CommentScalarFieldEnum
    orderBy: CommentOrderByWithRelationInput
    skip: Int
    take: Int
    where: CommentWhereInput
  ): [Comment!]!
  createdAt: DateTime!
  id: Int!
  postedAt: DateTime!
  title: String!
  updatedAt: DateTime!
  user: User!
  userId: Int!
}

type PostAvgAggregateOutputType {
  id: Float
  userId: Float
}

input PostAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type PostCountAggregateOutputType {
  _all: Int!
  body: Int!
  createdAt: Int!
  id: Int!
  postedAt: Int!
  title: Int!
  updatedAt: Int!
  userId: Int!
}

input PostCountOrderByAggregateInput {
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postedAt: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type PostCountOutputType {
  comments: Int!
}

input PostCreateInput {
  body: String!
  comments: CommentCreateNestedManyWithoutPostInput
  createdAt: DateTime
  postedAt: DateTime
  title: String!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutPostsInput!
}

input PostCreateManyInput {
  body: String!
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String!
  updatedAt: DateTime
  userId: Int!
}

input PostCreateManyUserInput {
  body: String!
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String!
  updatedAt: DateTime
}

input PostCreateManyUserInputEnvelope {
  data: PostCreateManyUserInput!
  skipDuplicates: Boolean
}

input PostCreateNestedManyWithoutUserInput {
  connect: [PostWhereUniqueInput]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput]
  create: [PostCreateWithoutUserInput]
  createMany: PostCreateManyUserInputEnvelope
}

input PostCreateNestedOneWithoutCommentsInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutCommentsInput
  create: PostUncheckedCreateWithoutCommentsInput
}

input PostCreateOrConnectWithoutCommentsInput {
  create: PostUncheckedCreateWithoutCommentsInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutUserInput {
  create: PostUncheckedCreateWithoutUserInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutCommentsInput {
  body: String!
  createdAt: DateTime
  postedAt: DateTime
  title: String!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutPostsInput!
}

input PostCreateWithoutUserInput {
  body: String!
  comments: CommentCreateNestedManyWithoutPostInput
  createdAt: DateTime
  postedAt: DateTime
  title: String!
  updatedAt: DateTime
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregateOutputType {
  body: String
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String
  updatedAt: DateTime
  userId: Int
}

input PostMaxOrderByAggregateInput {
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postedAt: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type PostMinAggregateOutputType {
  body: String
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String
  updatedAt: DateTime
  userId: Int
}

input PostMinOrderByAggregateInput {
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postedAt: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostOrderByWithAggregationInput {
  _avg: PostAvgOrderByAggregateInput
  _count: PostCountOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  _sum: PostSumOrderByAggregateInput
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postedAt: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostOrderByWithRelationInput {
  body: SortOrder
  comments: CommentOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  postedAt: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

enum PostScalarFieldEnum {
  body
  createdAt
  id
  postedAt
  title
  updatedAt
  userId
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput]
  NOT: [PostScalarWhereInput]
  OR: [PostScalarWhereInput]
  body: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  postedAt: DateTimeFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput]
  NOT: [PostScalarWhereWithAggregatesInput]
  OR: [PostScalarWhereWithAggregatesInput]
  body: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  postedAt: DateTimeWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type PostSumAggregateOutputType {
  id: Int
  userId: Int
}

input PostSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input PostUncheckedCreateInput {
  body: String!
  comments: CommentUncheckedCreateNestedManyWithoutPostInput
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String!
  updatedAt: DateTime
  userId: Int!
}

input PostUncheckedCreateNestedManyWithoutUserInput {
  connect: [PostWhereUniqueInput]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput]
  create: [PostCreateWithoutUserInput]
  createMany: PostCreateManyUserInputEnvelope
}

input PostUncheckedCreateWithoutCommentsInput {
  body: String!
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String!
  updatedAt: DateTime
  userId: Int!
}

input PostUncheckedCreateWithoutUserInput {
  body: String!
  comments: CommentUncheckedCreateNestedManyWithoutPostInput
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String!
  updatedAt: DateTime
}

input PostUncheckedUpdateInput {
  body: String
  comments: CommentUncheckedUpdateManyWithoutPostNestedInput
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String
  updatedAt: DateTime
  userId: Int
}

input PostUncheckedUpdateManyInput {
  body: String
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String
  updatedAt: DateTime
  userId: Int
}

input PostUncheckedUpdateManyWithoutPostsInput {
  body: String
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String
  updatedAt: DateTime
}

input PostUncheckedUpdateManyWithoutUserNestedInput {
  connect: [PostWhereUniqueInput]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput]
  create: [PostCreateWithoutUserInput]
  createMany: PostCreateManyUserInputEnvelope
  delete: [PostWhereUniqueInput]
  deleteMany: [PostScalarWhereInput]
  disconnect: [PostWhereUniqueInput]
  set: [PostWhereUniqueInput]
  update: [PostUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [PostUpdateManyWithWhereWithoutUserInput]
  upsert: [PostUpsertWithWhereUniqueWithoutUserInput]
}

input PostUncheckedUpdateWithoutCommentsInput {
  body: String
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String
  updatedAt: DateTime
  userId: Int
}

input PostUncheckedUpdateWithoutUserInput {
  body: String
  comments: CommentUncheckedUpdateManyWithoutPostNestedInput
  createdAt: DateTime
  id: Int
  postedAt: DateTime
  title: String
  updatedAt: DateTime
}

input PostUpdateInput {
  body: String
  comments: CommentUpdateManyWithoutPostNestedInput
  createdAt: DateTime
  postedAt: DateTime
  title: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPostsNestedInput
}

input PostUpdateManyMutationInput {
  body: String
  createdAt: DateTime
  postedAt: DateTime
  title: String
  updatedAt: DateTime
}

input PostUpdateManyWithWhereWithoutUserInput {
  data: PostUncheckedUpdateManyWithoutPostsInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutUserNestedInput {
  connect: [PostWhereUniqueInput]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput]
  create: [PostCreateWithoutUserInput]
  createMany: PostCreateManyUserInputEnvelope
  delete: [PostWhereUniqueInput]
  deleteMany: [PostScalarWhereInput]
  disconnect: [PostWhereUniqueInput]
  set: [PostWhereUniqueInput]
  update: [PostUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [PostUpdateManyWithWhereWithoutUserInput]
  upsert: [PostUpsertWithWhereUniqueWithoutUserInput]
}

input PostUpdateOneRequiredWithoutCommentsNestedInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutCommentsInput
  create: PostUncheckedCreateWithoutCommentsInput
  update: PostUncheckedUpdateWithoutCommentsInput
  upsert: PostUpsertWithoutCommentsInput
}

input PostUpdateWithWhereUniqueWithoutUserInput {
  data: PostUncheckedUpdateWithoutUserInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutCommentsInput {
  body: String
  createdAt: DateTime
  postedAt: DateTime
  title: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPostsNestedInput
}

input PostUpdateWithoutUserInput {
  body: String
  comments: CommentUpdateManyWithoutPostNestedInput
  createdAt: DateTime
  postedAt: DateTime
  title: String
  updatedAt: DateTime
}

input PostUpsertWithWhereUniqueWithoutUserInput {
  create: PostUncheckedCreateWithoutUserInput!
  update: PostUncheckedUpdateWithoutUserInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutCommentsInput {
  create: PostUncheckedCreateWithoutCommentsInput!
  update: PostUncheckedUpdateWithoutCommentsInput!
}

input PostWhereInput {
  AND: [PostWhereInput]
  NOT: [PostWhereInput]
  OR: [PostWhereInput]
  body: StringFilter
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  postedAt: DateTimeFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: IntFilter
}

input PostWhereUniqueInput {
  id: Int
}

type Query {
  aggregateComment(
    cursor: CommentWhereUniqueInput
    orderBy: [CommentOrderByWithRelationInput]
    skip: Int
    take: Int
    where: CommentWhereInput
  ): AggregateComment
  aggregatePost(
    cursor: PostWhereUniqueInput
    orderBy: [PostOrderByWithRelationInput]
    skip: Int
    take: Int
    where: PostWhereInput
  ): AggregatePost
  aggregateRating(
    cursor: RatingWhereUniqueInput
    orderBy: [RatingOrderByWithRelationInput]
    skip: Int
    take: Int
    where: RatingWhereInput
  ): AggregateRating
  aggregateUser(
    cursor: UserWhereUniqueInput
    orderBy: [UserOrderByWithRelationInput]
    skip: Int
    take: Int
    where: UserWhereInput
  ): AggregateUser
  findFirstComment(
    cursor: CommentWhereUniqueInput
    distinct: CommentScalarFieldEnum
    orderBy: [CommentOrderByWithRelationInput]
    skip: Int
    take: Int
    where: CommentWhereInput
  ): Comment
  findFirstPost(
    cursor: PostWhereUniqueInput
    distinct: PostScalarFieldEnum
    orderBy: [PostOrderByWithRelationInput]
    skip: Int
    take: Int
    where: PostWhereInput
  ): Post
  findFirstRating(
    cursor: RatingWhereUniqueInput
    distinct: RatingScalarFieldEnum
    orderBy: [RatingOrderByWithRelationInput]
    skip: Int
    take: Int
    where: RatingWhereInput
  ): Rating
  findFirstUser(
    cursor: UserWhereUniqueInput
    distinct: UserScalarFieldEnum
    orderBy: [UserOrderByWithRelationInput]
    skip: Int
    take: Int
    where: UserWhereInput
  ): User
  findManyComment(
    cursor: CommentWhereUniqueInput
    distinct: CommentScalarFieldEnum
    orderBy: [CommentOrderByWithRelationInput]
    skip: Int
    take: Int
    where: CommentWhereInput
  ): [Comment!]!
  findManyCommentCount(
    cursor: CommentWhereUniqueInput
    distinct: CommentScalarFieldEnum
    orderBy: [CommentOrderByWithRelationInput]
    skip: Int
    take: Int
    where: CommentWhereInput
  ): Int!
  findManyPost(
    cursor: PostWhereUniqueInput
    distinct: PostScalarFieldEnum
    orderBy: [PostOrderByWithRelationInput]
    skip: Int
    take: Int
    where: PostWhereInput
  ): [Post!]!
  findManyPostCount(
    cursor: PostWhereUniqueInput
    distinct: PostScalarFieldEnum
    orderBy: [PostOrderByWithRelationInput]
    skip: Int
    take: Int
    where: PostWhereInput
  ): Int!
  findManyRating(
    cursor: RatingWhereUniqueInput
    distinct: RatingScalarFieldEnum
    orderBy: [RatingOrderByWithRelationInput]
    skip: Int
    take: Int
    where: RatingWhereInput
  ): [Rating!]!
  findManyRatingCount(
    cursor: RatingWhereUniqueInput
    distinct: RatingScalarFieldEnum
    orderBy: [RatingOrderByWithRelationInput]
    skip: Int
    take: Int
    where: RatingWhereInput
  ): Int!
  findManyUser(
    cursor: UserWhereUniqueInput
    distinct: UserScalarFieldEnum
    orderBy: [UserOrderByWithRelationInput]
    skip: Int
    take: Int
    where: UserWhereInput
  ): [User!]!
  findManyUserCount(
    cursor: UserWhereUniqueInput
    distinct: UserScalarFieldEnum
    orderBy: [UserOrderByWithRelationInput]
    skip: Int
    take: Int
    where: UserWhereInput
  ): Int!
  findUniqueComment(where: CommentWhereUniqueInput!): Comment
  findUniquePost(where: PostWhereUniqueInput!): Post
  findUniqueRating(where: RatingWhereUniqueInput!): Rating
  findUniqueUser(where: UserWhereUniqueInput!): User
}

enum QueryMode {
  default
  insensitive
}

type Rating {
  createdAt: DateTime!
  id: Int!
  ratedAt: DateTime!
  rater: User!
  raterId: Int!
  rating: Int!
  updatedAt: DateTime!
  user: User!
  userId: Int!
}

type RatingAvgAggregateOutputType {
  id: Float
  raterId: Float
  rating: Float
  userId: Float
}

input RatingAvgOrderByAggregateInput {
  id: SortOrder
  raterId: SortOrder
  rating: SortOrder
  userId: SortOrder
}

type RatingCountAggregateOutputType {
  _all: Int!
  createdAt: Int!
  id: Int!
  ratedAt: Int!
  raterId: Int!
  rating: Int!
  updatedAt: Int!
  userId: Int!
}

input RatingCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  ratedAt: SortOrder
  raterId: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input RatingCreateInput {
  createdAt: DateTime
  ratedAt: DateTime
  rater: UserCreateNestedOneWithoutMyRatingsInput!
  rating: Int!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutRatingsInput!
}

input RatingCreateManyInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int!
  rating: Int!
  updatedAt: DateTime
  userId: Int!
}

input RatingCreateManyRaterInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  rating: Int!
  updatedAt: DateTime
  userId: Int!
}

input RatingCreateManyRaterInputEnvelope {
  data: RatingCreateManyRaterInput!
  skipDuplicates: Boolean
}

input RatingCreateManyUserInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int!
  rating: Int!
  updatedAt: DateTime
}

input RatingCreateManyUserInputEnvelope {
  data: RatingCreateManyUserInput!
  skipDuplicates: Boolean
}

input RatingCreateNestedManyWithoutRaterInput {
  connect: [RatingWhereUniqueInput]
  connectOrCreate: [RatingCreateOrConnectWithoutRaterInput]
  create: [RatingCreateWithoutRaterInput]
  createMany: RatingCreateManyRaterInputEnvelope
}

input RatingCreateNestedManyWithoutUserInput {
  connect: [RatingWhereUniqueInput]
  connectOrCreate: [RatingCreateOrConnectWithoutUserInput]
  create: [RatingCreateWithoutUserInput]
  createMany: RatingCreateManyUserInputEnvelope
}

input RatingCreateOrConnectWithoutRaterInput {
  create: RatingUncheckedCreateWithoutRaterInput!
  where: RatingWhereUniqueInput!
}

input RatingCreateOrConnectWithoutUserInput {
  create: RatingUncheckedCreateWithoutUserInput!
  where: RatingWhereUniqueInput!
}

input RatingCreateWithoutRaterInput {
  createdAt: DateTime
  ratedAt: DateTime
  rating: Int!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutRatingsInput!
}

input RatingCreateWithoutUserInput {
  createdAt: DateTime
  ratedAt: DateTime
  rater: UserCreateNestedOneWithoutMyRatingsInput!
  rating: Int!
  updatedAt: DateTime
}

input RatingListRelationFilter {
  every: RatingWhereInput
  none: RatingWhereInput
  some: RatingWhereInput
}

type RatingMaxAggregateOutputType {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int
  rating: Int
  updatedAt: DateTime
  userId: Int
}

input RatingMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  ratedAt: SortOrder
  raterId: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type RatingMinAggregateOutputType {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int
  rating: Int
  updatedAt: DateTime
  userId: Int
}

input RatingMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  ratedAt: SortOrder
  raterId: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input RatingOrderByRelationAggregateInput {
  _count: SortOrder
}

input RatingOrderByWithAggregationInput {
  _avg: RatingAvgOrderByAggregateInput
  _count: RatingCountOrderByAggregateInput
  _max: RatingMaxOrderByAggregateInput
  _min: RatingMinOrderByAggregateInput
  _sum: RatingSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  ratedAt: SortOrder
  raterId: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input RatingOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  ratedAt: SortOrder
  rater: UserOrderByWithRelationInput
  raterId: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum RatingScalarFieldEnum {
  createdAt
  id
  ratedAt
  raterId
  rating
  updatedAt
  userId
}

input RatingScalarWhereInput {
  AND: [RatingScalarWhereInput]
  NOT: [RatingScalarWhereInput]
  OR: [RatingScalarWhereInput]
  createdAt: DateTimeFilter
  id: IntFilter
  ratedAt: DateTimeFilter
  raterId: IntFilter
  rating: IntFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input RatingScalarWhereWithAggregatesInput {
  AND: [RatingScalarWhereWithAggregatesInput]
  NOT: [RatingScalarWhereWithAggregatesInput]
  OR: [RatingScalarWhereWithAggregatesInput]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  ratedAt: DateTimeWithAggregatesFilter
  raterId: IntWithAggregatesFilter
  rating: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type RatingSumAggregateOutputType {
  id: Int
  raterId: Int
  rating: Int
  userId: Int
}

input RatingSumOrderByAggregateInput {
  id: SortOrder
  raterId: SortOrder
  rating: SortOrder
  userId: SortOrder
}

input RatingUncheckedCreateInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int!
  rating: Int!
  updatedAt: DateTime
  userId: Int!
}

input RatingUncheckedCreateNestedManyWithoutRaterInput {
  connect: [RatingWhereUniqueInput]
  connectOrCreate: [RatingCreateOrConnectWithoutRaterInput]
  create: [RatingCreateWithoutRaterInput]
  createMany: RatingCreateManyRaterInputEnvelope
}

input RatingUncheckedCreateNestedManyWithoutUserInput {
  connect: [RatingWhereUniqueInput]
  connectOrCreate: [RatingCreateOrConnectWithoutUserInput]
  create: [RatingCreateWithoutUserInput]
  createMany: RatingCreateManyUserInputEnvelope
}

input RatingUncheckedCreateWithoutRaterInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  rating: Int!
  updatedAt: DateTime
  userId: Int!
}

input RatingUncheckedCreateWithoutUserInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int!
  rating: Int!
  updatedAt: DateTime
}

input RatingUncheckedUpdateInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int
  rating: Int
  updatedAt: DateTime
  userId: Int
}

input RatingUncheckedUpdateManyInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int
  rating: Int
  updatedAt: DateTime
  userId: Int
}

input RatingUncheckedUpdateManyWithoutMyRatingsInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  rating: Int
  updatedAt: DateTime
  userId: Int
}

input RatingUncheckedUpdateManyWithoutRaterNestedInput {
  connect: [RatingWhereUniqueInput]
  connectOrCreate: [RatingCreateOrConnectWithoutRaterInput]
  create: [RatingCreateWithoutRaterInput]
  createMany: RatingCreateManyRaterInputEnvelope
  delete: [RatingWhereUniqueInput]
  deleteMany: [RatingScalarWhereInput]
  disconnect: [RatingWhereUniqueInput]
  set: [RatingWhereUniqueInput]
  update: [RatingUpdateWithWhereUniqueWithoutRaterInput]
  updateMany: [RatingUpdateManyWithWhereWithoutRaterInput]
  upsert: [RatingUpsertWithWhereUniqueWithoutRaterInput]
}

input RatingUncheckedUpdateManyWithoutRatingsInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int
  rating: Int
  updatedAt: DateTime
}

input RatingUncheckedUpdateManyWithoutUserNestedInput {
  connect: [RatingWhereUniqueInput]
  connectOrCreate: [RatingCreateOrConnectWithoutUserInput]
  create: [RatingCreateWithoutUserInput]
  createMany: RatingCreateManyUserInputEnvelope
  delete: [RatingWhereUniqueInput]
  deleteMany: [RatingScalarWhereInput]
  disconnect: [RatingWhereUniqueInput]
  set: [RatingWhereUniqueInput]
  update: [RatingUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [RatingUpdateManyWithWhereWithoutUserInput]
  upsert: [RatingUpsertWithWhereUniqueWithoutUserInput]
}

input RatingUncheckedUpdateWithoutRaterInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  rating: Int
  updatedAt: DateTime
  userId: Int
}

input RatingUncheckedUpdateWithoutUserInput {
  createdAt: DateTime
  id: Int
  ratedAt: DateTime
  raterId: Int
  rating: Int
  updatedAt: DateTime
}

input RatingUpdateInput {
  createdAt: DateTime
  ratedAt: DateTime
  rater: UserUpdateOneRequiredWithoutMyRatingsNestedInput
  rating: Int
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutRatingsNestedInput
}

input RatingUpdateManyMutationInput {
  createdAt: DateTime
  ratedAt: DateTime
  rating: Int
  updatedAt: DateTime
}

input RatingUpdateManyWithWhereWithoutRaterInput {
  data: RatingUncheckedUpdateManyWithoutMyRatingsInput!
  where: RatingScalarWhereInput!
}

input RatingUpdateManyWithWhereWithoutUserInput {
  data: RatingUncheckedUpdateManyWithoutRatingsInput!
  where: RatingScalarWhereInput!
}

input RatingUpdateManyWithoutRaterNestedInput {
  connect: [RatingWhereUniqueInput]
  connectOrCreate: [RatingCreateOrConnectWithoutRaterInput]
  create: [RatingCreateWithoutRaterInput]
  createMany: RatingCreateManyRaterInputEnvelope
  delete: [RatingWhereUniqueInput]
  deleteMany: [RatingScalarWhereInput]
  disconnect: [RatingWhereUniqueInput]
  set: [RatingWhereUniqueInput]
  update: [RatingUpdateWithWhereUniqueWithoutRaterInput]
  updateMany: [RatingUpdateManyWithWhereWithoutRaterInput]
  upsert: [RatingUpsertWithWhereUniqueWithoutRaterInput]
}

input RatingUpdateManyWithoutUserNestedInput {
  connect: [RatingWhereUniqueInput]
  connectOrCreate: [RatingCreateOrConnectWithoutUserInput]
  create: [RatingCreateWithoutUserInput]
  createMany: RatingCreateManyUserInputEnvelope
  delete: [RatingWhereUniqueInput]
  deleteMany: [RatingScalarWhereInput]
  disconnect: [RatingWhereUniqueInput]
  set: [RatingWhereUniqueInput]
  update: [RatingUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [RatingUpdateManyWithWhereWithoutUserInput]
  upsert: [RatingUpsertWithWhereUniqueWithoutUserInput]
}

input RatingUpdateWithWhereUniqueWithoutRaterInput {
  data: RatingUncheckedUpdateWithoutRaterInput!
  where: RatingWhereUniqueInput!
}

input RatingUpdateWithWhereUniqueWithoutUserInput {
  data: RatingUncheckedUpdateWithoutUserInput!
  where: RatingWhereUniqueInput!
}

input RatingUpdateWithoutRaterInput {
  createdAt: DateTime
  ratedAt: DateTime
  rating: Int
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutRatingsNestedInput
}

input RatingUpdateWithoutUserInput {
  createdAt: DateTime
  ratedAt: DateTime
  rater: UserUpdateOneRequiredWithoutMyRatingsNestedInput
  rating: Int
  updatedAt: DateTime
}

input RatingUpsertWithWhereUniqueWithoutRaterInput {
  create: RatingUncheckedCreateWithoutRaterInput!
  update: RatingUncheckedUpdateWithoutRaterInput!
  where: RatingWhereUniqueInput!
}

input RatingUpsertWithWhereUniqueWithoutUserInput {
  create: RatingUncheckedCreateWithoutUserInput!
  update: RatingUncheckedUpdateWithoutUserInput!
  where: RatingWhereUniqueInput!
}

input RatingWhereInput {
  AND: [RatingWhereInput]
  NOT: [RatingWhereInput]
  OR: [RatingWhereInput]
  createdAt: DateTimeFilter
  id: IntFilter
  ratedAt: DateTimeFilter
  rater: UserWhereInput
  raterId: IntFilter
  rating: IntFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: IntFilter
}

input RatingWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

enum TransactionIsolationLevel {
  ReadCommitted
  ReadUncommitted
  RepeatableRead
  Serializable
}

type User {
  _count: UserCountOutputType!
  comments(
    cursor: CommentWhereUniqueInput
    distinct: CommentScalarFieldEnum
    orderBy: CommentOrderByWithRelationInput
    skip: Int
    take: Int
    where: CommentWhereInput
  ): [Comment!]!
  createdAt: DateTime!
  email: String!
  githubUsername: String
  id: Int!
  myRatings(
    cursor: RatingWhereUniqueInput
    distinct: RatingScalarFieldEnum
    orderBy: RatingOrderByWithRelationInput
    skip: Int
    take: Int
    where: RatingWhereInput
  ): [Rating!]!
  name: String!
  posts(
    cursor: PostWhereUniqueInput
    distinct: PostScalarFieldEnum
    orderBy: PostOrderByWithRelationInput
    skip: Int
    take: Int
    where: PostWhereInput
  ): [Post!]!
  ratings(
    cursor: RatingWhereUniqueInput
    distinct: RatingScalarFieldEnum
    orderBy: RatingOrderByWithRelationInput
    skip: Int
    take: Int
    where: RatingWhereInput
  ): [Rating!]!
  registeredAt: DateTime!
  updatedAt: DateTime!
}

type UserAvgAggregateOutputType {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCountAggregateOutputType {
  _all: Int!
  createdAt: Int!
  email: Int!
  githubUsername: Int!
  id: Int!
  name: Int!
  registeredAt: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  githubUsername: SortOrder
  id: SortOrder
  name: SortOrder
  registeredAt: SortOrder
  updatedAt: SortOrder
}

type UserCountOutputType {
  comments: Int!
  myRatings: Int!
  posts: Int!
  ratings: Int!
}

input UserCreateInput {
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  githubUsername: String
  myRatings: RatingCreateNestedManyWithoutRaterInput
  name: String!
  posts: PostCreateNestedManyWithoutUserInput
  ratings: RatingCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  githubUsername: String
  id: Int
  name: String!
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserUncheckedCreateWithoutCommentsInput
}

input UserCreateNestedOneWithoutMyRatingsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutMyRatingsInput
  create: UserUncheckedCreateWithoutMyRatingsInput
}

input UserCreateNestedOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  create: UserUncheckedCreateWithoutPostsInput
}

input UserCreateNestedOneWithoutRatingsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRatingsInput
  create: UserUncheckedCreateWithoutRatingsInput
}

input UserCreateOrConnectWithoutCommentsInput {
  create: UserUncheckedCreateWithoutCommentsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutMyRatingsInput {
  create: UserUncheckedCreateWithoutMyRatingsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutPostsInput {
  create: UserUncheckedCreateWithoutPostsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRatingsInput {
  create: UserUncheckedCreateWithoutRatingsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCommentsInput {
  createdAt: DateTime
  email: String!
  githubUsername: String
  myRatings: RatingCreateNestedManyWithoutRaterInput
  name: String!
  posts: PostCreateNestedManyWithoutUserInput
  ratings: RatingCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserCreateWithoutMyRatingsInput {
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  githubUsername: String
  name: String!
  posts: PostCreateNestedManyWithoutUserInput
  ratings: RatingCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserCreateWithoutPostsInput {
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  githubUsername: String
  myRatings: RatingCreateNestedManyWithoutRaterInput
  name: String!
  ratings: RatingCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserCreateWithoutRatingsInput {
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  githubUsername: String
  myRatings: RatingCreateNestedManyWithoutRaterInput
  name: String!
  posts: PostCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

type UserMaxAggregateOutputType {
  createdAt: DateTime
  email: String
  githubUsername: String
  id: Int
  name: String
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  githubUsername: SortOrder
  id: SortOrder
  name: SortOrder
  registeredAt: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregateOutputType {
  createdAt: DateTime
  email: String
  githubUsername: String
  id: Int
  name: String
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  githubUsername: SortOrder
  id: SortOrder
  name: SortOrder
  registeredAt: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  githubUsername: SortOrderInput
  id: SortOrder
  name: SortOrder
  registeredAt: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  comments: CommentOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  githubUsername: SortOrderInput
  id: SortOrder
  myRatings: RatingOrderByRelationAggregateInput
  name: SortOrder
  posts: PostOrderByRelationAggregateInput
  ratings: RatingOrderByRelationAggregateInput
  registeredAt: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  githubUsername
  id
  name
  registeredAt
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput]
  NOT: [UserScalarWhereWithAggregatesInput]
  OR: [UserScalarWhereWithAggregatesInput]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  githubUsername: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  registeredAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregateOutputType {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUncheckedCreateInput {
  comments: CommentUncheckedCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  githubUsername: String
  id: Int
  myRatings: RatingUncheckedCreateNestedManyWithoutRaterInput
  name: String!
  posts: PostUncheckedCreateNestedManyWithoutUserInput
  ratings: RatingUncheckedCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutCommentsInput {
  createdAt: DateTime
  email: String!
  githubUsername: String
  id: Int
  myRatings: RatingUncheckedCreateNestedManyWithoutRaterInput
  name: String!
  posts: PostUncheckedCreateNestedManyWithoutUserInput
  ratings: RatingUncheckedCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutMyRatingsInput {
  comments: CommentUncheckedCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  githubUsername: String
  id: Int
  name: String!
  posts: PostUncheckedCreateNestedManyWithoutUserInput
  ratings: RatingUncheckedCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutPostsInput {
  comments: CommentUncheckedCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  githubUsername: String
  id: Int
  myRatings: RatingUncheckedCreateNestedManyWithoutRaterInput
  name: String!
  ratings: RatingUncheckedCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutRatingsInput {
  comments: CommentUncheckedCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  githubUsername: String
  id: Int
  myRatings: RatingUncheckedCreateNestedManyWithoutRaterInput
  name: String!
  posts: PostUncheckedCreateNestedManyWithoutUserInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedUpdateInput {
  comments: CommentUncheckedUpdateManyWithoutUserNestedInput
  createdAt: DateTime
  email: String
  githubUsername: String
  id: Int
  myRatings: RatingUncheckedUpdateManyWithoutRaterNestedInput
  name: String
  posts: PostUncheckedUpdateManyWithoutUserNestedInput
  ratings: RatingUncheckedUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedUpdateManyInput {
  createdAt: DateTime
  email: String
  githubUsername: String
  id: Int
  name: String
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedUpdateWithoutCommentsInput {
  createdAt: DateTime
  email: String
  githubUsername: String
  id: Int
  myRatings: RatingUncheckedUpdateManyWithoutRaterNestedInput
  name: String
  posts: PostUncheckedUpdateManyWithoutUserNestedInput
  ratings: RatingUncheckedUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedUpdateWithoutMyRatingsInput {
  comments: CommentUncheckedUpdateManyWithoutUserNestedInput
  createdAt: DateTime
  email: String
  githubUsername: String
  id: Int
  name: String
  posts: PostUncheckedUpdateManyWithoutUserNestedInput
  ratings: RatingUncheckedUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedUpdateWithoutPostsInput {
  comments: CommentUncheckedUpdateManyWithoutUserNestedInput
  createdAt: DateTime
  email: String
  githubUsername: String
  id: Int
  myRatings: RatingUncheckedUpdateManyWithoutRaterNestedInput
  name: String
  ratings: RatingUncheckedUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUncheckedUpdateWithoutRatingsInput {
  comments: CommentUncheckedUpdateManyWithoutUserNestedInput
  createdAt: DateTime
  email: String
  githubUsername: String
  id: Int
  myRatings: RatingUncheckedUpdateManyWithoutRaterNestedInput
  name: String
  posts: PostUncheckedUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUpdateInput {
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: DateTime
  email: String
  githubUsername: String
  myRatings: RatingUpdateManyWithoutRaterNestedInput
  name: String
  posts: PostUpdateManyWithoutUserNestedInput
  ratings: RatingUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUpdateManyMutationInput {
  createdAt: DateTime
  email: String
  githubUsername: String
  name: String
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUpdateOneRequiredWithoutCommentsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserUncheckedCreateWithoutCommentsInput
  update: UserUncheckedUpdateWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneRequiredWithoutMyRatingsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutMyRatingsInput
  create: UserUncheckedCreateWithoutMyRatingsInput
  update: UserUncheckedUpdateWithoutMyRatingsInput
  upsert: UserUpsertWithoutMyRatingsInput
}

input UserUpdateOneRequiredWithoutPostsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  create: UserUncheckedCreateWithoutPostsInput
  update: UserUncheckedUpdateWithoutPostsInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateOneRequiredWithoutRatingsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRatingsInput
  create: UserUncheckedCreateWithoutRatingsInput
  update: UserUncheckedUpdateWithoutRatingsInput
  upsert: UserUpsertWithoutRatingsInput
}

input UserUpdateWithoutCommentsInput {
  createdAt: DateTime
  email: String
  githubUsername: String
  myRatings: RatingUpdateManyWithoutRaterNestedInput
  name: String
  posts: PostUpdateManyWithoutUserNestedInput
  ratings: RatingUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUpdateWithoutMyRatingsInput {
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: DateTime
  email: String
  githubUsername: String
  name: String
  posts: PostUpdateManyWithoutUserNestedInput
  ratings: RatingUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUpdateWithoutPostsInput {
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: DateTime
  email: String
  githubUsername: String
  myRatings: RatingUpdateManyWithoutRaterNestedInput
  name: String
  ratings: RatingUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUpdateWithoutRatingsInput {
  comments: CommentUpdateManyWithoutUserNestedInput
  createdAt: DateTime
  email: String
  githubUsername: String
  myRatings: RatingUpdateManyWithoutRaterNestedInput
  name: String
  posts: PostUpdateManyWithoutUserNestedInput
  registeredAt: DateTime
  updatedAt: DateTime
}

input UserUpsertWithoutCommentsInput {
  create: UserUncheckedCreateWithoutCommentsInput!
  update: UserUncheckedUpdateWithoutCommentsInput!
}

input UserUpsertWithoutMyRatingsInput {
  create: UserUncheckedCreateWithoutMyRatingsInput!
  update: UserUncheckedUpdateWithoutMyRatingsInput!
}

input UserUpsertWithoutPostsInput {
  create: UserUncheckedCreateWithoutPostsInput!
  update: UserUncheckedUpdateWithoutPostsInput!
}

input UserUpsertWithoutRatingsInput {
  create: UserUncheckedCreateWithoutRatingsInput!
  update: UserUncheckedUpdateWithoutRatingsInput!
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  githubUsername: StringNullableFilter
  id: IntFilter
  myRatings: RatingListRelationFilter
  name: StringFilter
  posts: PostListRelationFilter
  ratings: RatingListRelationFilter
  registeredAt: DateTimeFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
